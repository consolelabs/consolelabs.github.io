[{"id":0,"href":"/playbook/format-profile--number/","title":"Guideline: Format a Mochi profile \u0026 Number.","section":"Playbooks","content":"When it comes to a UI rendering, there is no such things as a \u0026ldquo;correct way\u0026rdquo;\n"},{"id":1,"href":"/playbook/mochi-ui/","title":"How to use a shared UI library in multiple platforms.","section":"Playbooks","content":"by hnh.\nBackground # Earlier this year, we introduced a new version of Telegram for Mochi, but it came with some new challenges.\nUp until now, we\u0026rsquo;ve been using a single backend system to support all of our services. This approach was taken to ensure a smooth experience for both users and engineers across different platforms. However, a problem arose when it came to the user interface. We found ourselves dealing with two different sets of rules (Discord \u0026amp; Telegram) for how the interface should look and behave. This complexity kept growing as we added new features and concepts. Eventually, we reached a point where it became nearly impossible to maintain consistency between the two platforms. Worth noting that, we also aim to have a Web, Mobile \u0026amp; Raycast versions for Mochi.\nTo solve these problems and make sure everyone has a similar and easy experience, we realized we need a library that contains all our UI stuff that everyone can use.\nBut, making this library work on different platforms isn\u0026rsquo;t simple. It needs to be easy enough for our frontend team to use, also flexible enough to work on all platforms.\nWins # Flatten the learning curves. # You might not know this, but our frontend team only has 2 full-time members who really understand all the business and technical stuff. And we have 3 platforms to take care of. So, we definitely need some extra help from our community through our \u0026lsquo;Bounty Program.\u0026rsquo;\nLuckily, thanks to our shared library, the process is pretty simple now.\nBefore:\nA: Hey, can you help me with this feature? A: This feature will be on Discord, Telegram, and the website. Here\u0026#39;s how it should work on each platform. A: Make sure to create test files for all the platforms because we make changes frequently. A: Oh, and please document it somewhere because I might forget. B: ... Now:\nA: Hey, can you help me with this feature? A: All you need to do is use a function from a well-tested and clearly defined source. B: Sure! Consistency throughout the systems # Dealing with the nitty-gritty details can be quite challenging. Often, we overlook small things like how to display numbers or whether we should add a period at the end of a sentence.\nHandling these details on just one platform is tough, and when it comes to managing them on five different platforms, it feels nearly impossible. Our daily meetings are increasingly filled with questions like, \u0026ldquo;Hey, did you make this change on Discord but forget about it on Telegram?\u0026rdquo; and vice versa.\nAfter we introduced mochi-ui our focus shifted from dealing with technical issues to more meaningful questions like, \u0026ldquo;Does this feature actually make sense?\u0026rdquo; or \u0026ldquo;Hey, this is a bug report from a user, can someone look into it?\u0026rdquo; These are the kinds of challenges we are more than happy to face.\nGotchas # Of course, there\u0026rsquo;s no one-size-fits-all solution, especially on the first attempt. We\u0026rsquo;ve identified some issues, and we\u0026rsquo;d be glad to have your hand in addressing them:\nLack of Local Preview: Currently, we don\u0026rsquo;t have a way to preview changes locally. The only option is to update the package and check it in our development environments. Text-Based Components: Some of our components are still text-based, which could be limiting if we need to use them in web applications. Single point of failure: Since \u0026lsquo;mochi-ui\u0026rsquo; is centralized as the only implementation, we must ensure it\u0026rsquo;s robust and fast. Some rendering logic still requires API calls, and we need to find ways to eliminate this dependency. Final thoughts # This approach is not and never a silver-bullet and may not be appropriate in all cases. However, we believe that this implementation has made our lives a bit less stressful by allowing us to shift our focus to other areas.\nThis blog post is part of our Mochi Frontend Practices, also check out:\nHow we using mock data to fasten our UI development Guidelines: How to render currency and profile name Applying state machine to switch UI view "},{"id":2,"href":"/playbook/integrate-new-chains/","title":"Integrate new chain into Mochi","section":"Playbooks","content":"by hnh, vhbien\nIn the rapidly evolving blockchain industry, it\u0026rsquo;s crucial to keep up with the pace of change. Here\u0026rsquo;s a quick overview of how we seamlessly integrate new chains into the Mochi system, with the caveat that this method is specific to EVM-based blockchains:\n[ ] Product Preparation [ ] Pull raw data into clickhouse [ ] Ticker, Watchlist Token Info [ ] Wallet tracking on this new chain [ ] Show assets in profile [ ] Transfer / Tip / Airdrop / Payme / Paylink [ ] Withdraw [ ] Deposit\n[0] Product Preparation # In this section, most of the tasks require manual handling.\nAdd new chain to supported chain list\nGo to Mochi Pay repository. Create a migration file as show below. INSERT INTO \u0026#34;public\u0026#34;.\u0026#34;product_supported_chains\u0026#34; (\u0026#34;chain_id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;symbol\u0026#34;, \u0026#34;rpc\u0026#34;, \u0026#34;explorer\u0026#34;, \u0026#34;icon\u0026#34;, \u0026#34;is_evm\u0026#34;,) VALUES (\u0026#39;1\u0026#39;, \u0026#39;Ethereum Mainnet\u0026#39;, \u0026#39;ETH\u0026#39;, \u0026#39;https://eth.llamarpc.com\u0026#39;, \u0026#39;https://etherscan.io\u0026#39;, \u0026#39;https://cdn.discordapp.com/emojis/928216430451761172.png?size=240\u0026amp;quality=lossless\u0026#39;, \u0026#39;t\u0026#39;), use the /chains command to see the new changes. Add token emojis To enhance the aesthetics of Mochi, we aim to display token emojis whenever possible. Currently, please reach out to @minh_cloud for assistance with this task.\n[1] Pull raw data into clickhouse # To store blockchain raw events data in ClickHouse, follow these steps:\nGo to Infras repository Create a service with the following configuration, similar to the example evm: chainName: base chainId: 8453 rpcServers: - https://1rpc.io/base - https://base.meowrpc.com - https://mainnet.base.org - https://base.blockpi.network/v1/rpc/public syncFromBlockNumber: 2769582 [2] Ticker, watchlist and Token info # This step should work automatically. Simply go to Mochi Clients and test out some well-known tokens to ensure that everything is functioning as expected.\n[3] Wallet tracking # Wallet tracking is managed within the account-telemetry repository, , follow these tasks:\nVerify Clickhouse Database Data: Check the Clickhouse database to ensure it contains data for the new chains. Specifically, verify the latest_block_timestamp table to confirm that it has the necessary records for the new chain. Ensure that the latest_block_timestamp column is up to date and reflects the latest block timestamp for the new chain. Update utils package: Update the chain.go file to add support for the new chain. This involves adding the necessary configurations and logic to handle the data retrieval and notification process for the new chain. By completing these tasks, you\u0026rsquo;ll ensure that wallet tracking in the account-telemetry repository works seamlessly with the new chains, allowing for accurate notifications to users when their tracked accounts receive new transactions.\n[4] Show assets in Profile # [5] Transfer / Tip / Airdrop / Payme / Paylink # This step should work automatically. Simply go to Mochi Clients and test out some well-known tokens to ensure that everything is functioning as expected.\n[6] Withdraw # This step should work automatically. Simply go to Mochi Clients and test out some well-known tokens to ensure that everything is functioning as expected.\n[7] Deposit # To enable support for deposits on a new chain, follow these essential steps:\nCompile and Deploy Deposit Contract:\nCompile the deposit contract using the contract available in the consolelabs/contract-tip-bot repository. Deploy the compiled deposit contract to the new chain. Ensure that the deployment is successful and that the contract is functioning as expected. Change Ownership to Centralized Wallet Address:\nChange the ownership of the deployed deposit contract to a centralized wallet address. Seed Deposit Contract Information:\nUpdate the mochi_pay_api by adding information about the newly deployed deposit contract to the deposit_contracts table. This includes details such as the contract address and other relevant information. Test Deposits:\nPerform testing to ensure that deposits work smoothly on the new chain. Test depositing a few tokens to verify that the deposit functionality is working as intended. "},{"id":3,"href":"/mission/","title":"mission","section":"","content":"Here is an example mission statement lol\n"},{"id":4,"href":"/mocking-test-to-deploy-as-an-example/","title":"Mocking Test to deploy as an example","section":"","content":" Introduction # This is a simple example\nWe will link the following pages:\nmission "},{"id":5,"href":"/about/","title":"About","section":"","content":" About # mission philosophy "}]