<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta name=description content><link rel=icon type=image/x-icon href=https://log.console.so/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://log.console.so/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://log.console.so/favicon-32x32.png><link rel=apple-touch-icon href=https://log.console.so/apple-touch-icon.png><title>Data layer | Console Labs</title><meta name=description content><link rel=canonical href=https://log.console.so/playbook/data-layer/><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>:root{--primary-color:#45f1a6;--primary-color-light:#2ea370;--nav-sidebar-width:200px;--nav-sidebar-offset:40px}body{font:16px sans-serif;color:#000;text-rendering:optimizeLegibility;padding:2rem;max-width:100%;margin:0;padding:0;background-color:#fff;line-height:25px;min-height:100vh;display:flex;flex-direction:column}h1,h2,h3,h4{color:var(--primary-color)}h1{font-size:45px;text-transform:capitalize;display:none}h2{font-size:30px;text-transform:capitalize}h3{font-size:20px;text-transform:capitalize}h4{font-size:15px;text-transform:capitalize}q{font-size:20px;max-width:500px;display:block;margin-left:30px}pre{font-family:monospace;background:#000;color:#fff;padding:15px;border-radius:2px;overflow-x:auto}pre>code{display:block;text-indent:0;white-space:inherit;font-weight:400}code{font-family:monospace;font-size:12px;background:#000;color:#fff;padding:2px 5px;white-space:pre;border-radius:2px;font-weight:700;display:inline-block;line-height:16px}code comment{color:#777}code.button{background:#fff;color:#000;font-size:smaller;display:inline-block;padding:0 6px;font-weight:700;border-radius:2px;line-height:22px}a[href*="#"]{text-decoration:none}nav.menu{float:left;padding:45px;max-width:var(--nav-sidebar-width);line-height:22px;margin-top:-2px}nav .site-nav{margin:20px 0;display:block}nav .site-nav section{float:left;margin-top:-2px}nav .site-nav section h2{margin:20px 0;font-size:24px;text-transform:lowercase}nav.menu details summary{margin-bottom:30px}@media(max-width:1100px){nav.menu{width:100%;max-width:100%}}nav.menu ul{padding:0 10px 10px 0;margin:0;list-style-type:none;line-height:22px}main{padding:45px;max-width:700px;float:left}main>ul{line-height:25px;margin:0}main>ul>li>a{text-decoration:underline}.dual-list>ul{columns:2}.single-list>ul{columns:2}#TableOfContents>ul>li>a{text-decoration:underline}#TableOfContents>ul{columns:2;line-height:20px}#TableOfContents li{list-style-type:decimal-leading-zero;list-style-position:inside;text-transform:capitalize}.notice{padding:20px;border:2px solid #000}main>blockquote{padding:20px;border:2px solid #000}main>*{max-width:600px;margin-bottom:30px}header{padding:45px;border-bottom:1px solid #222}header a img{filter:invert(0)}header h1{display:inline}footer{margin-top:auto;padding:45px;clear:both}nav .site-nav ul li{list-style-type:none;display:flex;font-variant-numeric:tabular-nums}li:has(input[type=checkbox]){display:block;list-style-type:none}ul:has(li input[type=checkbox]){padding:0}section>ul li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;width:calc(var(--nav-sidebar-width) + var(--nav-sidebar-offset));background-color:#fff}ul li{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;background-color:#fff}ul li a:hover{white-space:nowrap;width:100%;z-index:10}time{padding-right:1rem}blockquote{margin:1em 0;padding:0 2em;border-left:3px solid #eee}img{max-width:100%}a,a:visited{color:#000}@media(prefers-color-scheme:dark){a,a:visited{color:#fff}body{background:#000;color:#fff}header a img{filter:invert(1)}body a{color:#fff}pre{background:#fff;color:#000}code{background:#fff;color:#000}body select{color:#000;background-color:#fff}.project{border-left:2px solid #fff}.notice{border-color:#fff}.mono{filter:invert(1)}.progress>div{background-color:#fff}.progress>div>span{color:#000}main>blockquote{border-color:#fff}ul li a{background-color:#000}ul{background-color:#000}}@media(prefers-color-scheme:light){h1,h2,h3,h4{color:var(--primary-color-light)}}@media(max-width:1100px){nav{width:100%}nav .site-nav section{float:left;margin:0 10px 10px 0}}@media(max-width:1100px) and (min-width:651px){nav .site-nav section{width:calc(25% - 10px)}nav .site-nav section:nth-child(4n+1){clear:left}}@media(max-width:650px) and (min-width:501px){nav .site-nav section{width:calc(33% - 10px)}nav .site-nav section:nth-child(3n+1){clear:left}}@media(max-width:500px) and (min-width:351px){nav .site-nav section{width:calc(50% - 10px)}nav .site-nav section:nth-child(2n+1){clear:left}}@media(max-width:350px){nav .site-nav section{width:100%}}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"playbook","name":"Data layer","headline":"Data layer","alternativeHeadline":"","description":"by hnh\nThis data layer serves as the central source of information for various features such as tickers, price alerts, and token details. These features rely on the data within this layer to provide accurate and up-to-date information to users. In essence, it\u0026rsquo;s like the beating heart of the mochi ecosystem, ensuring that all the essential data is readily available for users to access and use.\nRaw Data The raw data that powers our system originates from blockchain transaction data, which we can retrieve from various RPC sources.","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/log.console.so\/playbook\/data-layer\/"},"author":{"@type":"Person","name":"Han Ngo"},"creator":{"@type":"Person","name":"Han Ngo"},"accountablePerson":{"@type":"Person","name":"Han Ngo"},"copyrightHolder":"Console Labs","copyrightYear":"2023","date":"2023-09-15T00:00:00.00Z","dateCreated":"2023-09-15T00:00:00.00Z","datePublished":"2023-09-15T00:00:00.00Z","dateModified":"2023-09-15T00:00:00.00Z","publisher":{"@type":"Organization","name":"Console Labs","url":"https://log.console.so/","logo":{"@type":"ImageObject","url":"https:\/\/log.console.so\/","width":"32","height":"32"}},"image":"https://log.console.so/","url":"https:\/\/log.console.so\/playbook\/data-layer\/","wordCount":"1172","genre":["payment","guideline"],"keywords":["payment","guideline"]}</script></head><body class=playbook><header><a href=/><img src=https://log.console.so/img/ConsoleLabs_logo.png alt=ConsoleLabs height=103px style="margin:-28px -26px"></a></header><div><nav class=menu><details open><summary>Menu</summary><section class=site-nav><section><ul><li><a href=/about/>About Us</a></li><li><a href=/contributors/>Contributors</a></li><li><a href=/philosophy/>Philosophy</a></li><li><a href=/purpose/>Purpose</a></li></ul></section><section><h2>experiments</h2><ul><li><a href=/experiments/neko/>CyberNeko NFT</a></li><li><a href=/experiments/emoji/>Emoji</a></li><li><a href=/experiments/kekk/>Kekcoin</a></li><li><a href=/experiments/mochi/>Mochi</a></li><li><a href=/experiments/pod-town/>Pod Town</a></li><li><a href=/experiments/wagmi/>WAGMI comics</a></li></ul></section><section><h2>blog</h2><ul><li><a href=/blog/log/>Log</a></li><li><a href=/blog/shape-up/>Shape Up</a></li></ul></section><section><h2>playbook</h2><ul><li><a href=/playbook/api-first/>API-first development</a></li><li><a href=/playbook/ci-cd/>Continuous Integration</a></li><li><a href=/playbook/data-layer/>Data layer</a></li><li><a href=/playbook/format-profile-number/>Format a Neko profile</a></li><li><a href=/playbook/render-emoji/>How to work with emoji on Discord</a></li><li><a href=/playbook/add-new-chains/>Integrate new chain</a></li><li><a href=/playbook/integrate-mochi-balances/>Leverage Mochi balances</a></li><li><a href=/playbook/meaningful-commit/>Meaningful commit message</a></li><li><a href=/playbook/shared-ui-lib/>Shared UI library in multiple platforms</a></li></ul></section></section></details></nav><main><aside class=toc><nav id=TableOfContents><ul><li><a href=#raw-data>Raw Data</a></li><li><a href=#token-data>Token data</a></li><li><a href=#gotchas>Gotchas</a></li></ul></nav></aside><p>by hnh</p><p><img src=/playbook/../images/playbook/data-flow.png></p><p>This data layer serves as the central source of information for various features such as tickers, price alerts, and token details. These features rely on the data within this layer to provide accurate and up-to-date information to users. In essence, it&rsquo;s like the beating heart of the mochi ecosystem, ensuring that all the essential data is readily available for users to access and use.</p><h2 id=raw-data><a href=#raw-data>Raw Data <a href=#raw-data></a></a></h2><p>The raw data that powers our system originates from blockchain transaction data, which we can retrieve from various RPC sources. However, maintaining a stable and consistent RPC connection has proven to be challenging in our past experiences. To address this issue, we&rsquo;ve adopted a different approach. We pull all the raw data into our Clickhouse database, where we store it for a period of 30 days before it&rsquo;s automatically deleted.</p><p>This raw data plays a crucial role in providing transaction notifications to our users. Any transaction originating from wallets that we track is processed by our system. If a tracked wallet engages in a transaction, our system ensures that users are promptly notified about it. This process allows us to deliver real-time transaction updates and information to our users reliably.</p><h2 id=token-data><a href=#token-data>Token data <a href=#token-data></a></a></h2><p>Token data encompasses several important aspects:</p><ul><li><p>Token Info: This component provides project metadata, including details such as the project&rsquo;s Twitter account, website, and a concise project description. We retrieve this information from sources like Etherscan or CoinGecko.</p></li><li><p>Price Info: Calculating price information ourselves can be redundant and resource-intensive. Instead, we rely on established sources like CoinGecko, which offers a stable API with reasonable costs. This allows us to provide accurate and up-to-date price data to our users without reinventing the wheel.</p></li><li><p>Dex Data: Dex data represents the most comprehensive information about each token. It includes details about which decentralized exchanges (dex) currently list the token and provides data such as the number of token holders or trading volume for each day. Rather than calculating this information in-house, we source it from multiple data sources and store it in our data layer. This approach ensures that our users have access to comprehensive dex-related data for each token without the need for extensive calculations on our part.</p></li></ul><h2 id=gotchas><a href=#gotchas>Gotchas <a href=#gotchas></a></a></h2><h3 id=query-speed><a href=#query-speed>Query speed <a href=#query-speed></a></a></h3><p>When it comes to building online services, speed is a top priority. As our data layer continues to grow, we&rsquo;ve implemented several optimization strategies to ensure efficient and fast data retrieval:</p><p>Caching Frequently Accessed Data: To address the need for frequently queried data like token prices and metadata (such as emoji associated with tokens), we employ short-lived Redis caching. This allows us to store this data temporarily in a highly responsive cache, reducing the need to query the upstream services or databases repeatedly for the same information. Caching helps deliver swift responses to user requests.
Read Replicas and Data Partitioning: For data that cannot be cached due to its infrequent use or size, we&rsquo;ve taken a two-pronged approach. First, we&rsquo;ve created read replicas within our PostgreSQL layer. These replicas serve as copies of our main database, dedicated to handling read requests. This not only spreads the load but also improves query response times.
Additionally, we&rsquo;ve optimized data storage and retrieval by partitioning our most frequently accessed tables. Partitioning involves breaking these tables into smaller, more manageable parts based on certain criteria (e.g., time, category, or other relevant factors). This partitioning strategy significantly enhances query performance, as it reduces the amount of data that needs to be scanned or processed during each query. This combination of read replicas and data partitioning ensures that we can maintain high-speed access to our data even as our data layer continues to expand.</p><h3 id=data-realtime-ness><a href=#data-realtime-ness>Data Realtime-ness <a href=#data-realtime-ness></a></a></h3><p>Ensuring real-time data accuracy for crucial information like token prices is essential to avoid missing any market movements. However, for certain types of data like total assets and token info, real-time updates can be delayed without significantly impacting user experience. Here&rsquo;s how we manage this balance:</p><p>Real-time Data for Price Updates: For data that requires real-time accuracy, such as token prices, we prioritize instant updates. This ensures that our users receive the most up-to-date information, especially those who rely on timely market data. Real-time data is essential to provide users with the information they need to make informed decisions in the fast-paced world of cryptocurrencies.</p><p>Delayed Data for Less Critical Information: To reduce stress on our system and enhance the overall user experience, we introduce a slight delay in updating less critical information, such as total assets and token details. This delay allows us to optimize data processing and avoid overwhelming our resources. From the perspective of most users, this data still appears to be served instantly, ensuring a seamless experience.</p><p>Prioritizing Real-time Data for Top Users: Recognizing the importance of real-time data for our top users, we&rsquo;ve implemented a ranking system. The most active users or those with specific access privileges can enjoy the benefit of receiving data in real-time with minimal delay. This approach ensures that our highest-priority users have access to the most critical data without compromise.</p><p>Background Jobs for Data Handling: To manage these data updates efficiently, we handle most data processing as background jobs. This allows us to update and synchronize information without disrupting the user interface or slowing down the system&rsquo;s responsiveness. By running these tasks in the background, we maintain a balance between real-time data needs and system stability.</p><p>In summary, our approach involves a careful balance between real-time data for critical information and slightly delayed updates for less critical data. This strategy, combined with a ranking system and background job processing, allows us to provide both real-time accuracy and a smooth user experience while managing system resources effectively.</p><h3 id=maintain-an-affordable-sassinfras-price><a href=#maintain-an-affordable-sassinfras-price>Maintain an affordable SaSS/infras price <a href=#maintain-an-affordable-sassinfras-price></a></a></h3><p>Maintaining a reasonable cost for the data layer is crucial for the sustainability of your online service. Here&rsquo;s how you approach cost management:</p><ol><li>Start with Third-Party Services: When in doubt, opting for third-party services is often the most cost-effective and efficient choice. These services are specialized and can save you time and resources in the short term. Even if they come with a monthly cost, as you mentioned, they often offer a great value proposition by allowing you to focus on other aspects of your platform.</li><li>Continuous Evaluation: Periodically assess the cost-effectiveness of the third-party services you use. Determine if the expense is justified by the benefits they provide. If a service becomes too costly or if you outgrow it, consider alternatives or building an in-house solution.</li><li>Building In-House Solutions: As your platform matures and your needs become more complex, it may become financially prudent to build certain services in-house. By doing so, you have more control over costs, scalability, and customization. However, this should be a well-considered decision, as it often involves higher initial investments in development and ongoing maintenance.</li><li>Cost Monitoring and Optimization: Implement robust cost monitoring and optimization practices. Keep an eye on data usage, query efficiency, and infrastructure costs. Use cloud provider tools to track spending and optimize resources accordingly. Often, small adjustments can lead to significant cost savings.</li></ol></main></div></body></html><footer><hr><span style=float:right>Edited on Sep 15, 2023<br></span><b>Console Labs</b> © 2023 — <a href=https://github.com/consolelabs/consolelabs.github.io/blob/main/LICENSE.by-nc-sa-4.0.md target=_blank>BY-NC-SA 4.0</a></footer>